% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SAEnet.R
\name{saenet}
\alias{saenet}
\title{Structure-Adaptive Elastic Net}
\usage{
saenet(
  formula,
  data,
  x,
  y,
  structure_info,
  max_iterations = 5,
  standardize = TRUE,
  alpha_sequence = seq(0, 1, by = 0.1),
  nlambda = 100,
  lambda_min_ratio = NULL,
  lambda_selection_rule = c("lambda.min", "lambda.1se", "bic"),
  gamma_sequence = seq(0.1, 1, by = 0.1),
  num_folds = 10,
  num_cores = 1,
  verbose = TRUE
)
}
\arguments{
\item{formula}{An object of class formula: a symbolic description of the model to be fitted}

\item{data}{A data frame containing the variables in the model}

\item{x}{Design matrix of predictors (n Ã— p) (alternative to formula/data)}

\item{y}{Response vector (alternative to formula/data)}

\item{structure_info}{External structural information. Can be:
\itemize{
  \item NULL: No structural information (standard adaptive elastic net)
  \item List with `group`: Group-based structural info with `$group` component
        indicating group membership
  \item List with `covariate`: Covariate-dependent structural info with `$covariate`
        component containing covariate values
}}

\item{max_iterations}{Number of iterations for the adaptive penalty procedure (default: 5)}

\item{standardize}{Logical. Whether to standardize the predictors (default: TRUE)}

\item{alpha_sequence}{A sequence of elastic net mixing parameters (0 <= alpha <= 1) to try,
where alpha=1 is lasso and alpha=0 is ridge (default: seq(0, 1, by = 0.1))}

\item{nlambda}{Number of lambda values to generate in the sequence (default: 100)}

\item{lambda_min_ratio}{Ratio of smallest to largest lambda value in the sequence.
If NULL, defaults to 1e-4 for n >= p, and 0.01 for n < p (default: NULL).}

\item{lambda_selection_rule}{Character string specifying the rule for selecting the optimal lambda from
cross-validation. Options are:
\itemize{
  \item `"lambda.min"`: (Default) The lambda that gives the minimum mean cross-validated error.
  \item `"lambda.1se"`: The largest lambda such that the cross-validated error is within one
        standard error of the minimum. This typically results in a more parsimonious model.
}}

\item{gamma_sequence}{A sequence of power parameters for adaptive weights
(default: seq(0.1, 1, by = 0.1))}

\item{num_folds}{Number of folds for cross-validation (default: 10)}

\item{num_cores}{Number of cores for parallel computation (default: 1)}

\item{verbose}{Logical. Whether to print progress messages (default: TRUE)}
}
\value{
An object of class "saenet" with the following components:
  \itemize{
    \item intercept: Vector of estimated intercept values for each iteration
    \item coefficients: Matrix of estimated coefficient vectors (on original scale)
          with columns corresponding to iterations
    \item weights: Matrix of adaptive weights for each iteration
    \item cv_errors: Vector of cross-validation errors for each iteration
          (corresponding to the selected lambda based on `lambda_selection_rule`)
    \item lambda: Vector of selected lambda parameters for each iteration
    \item alpha: Vector of selected alpha parameters for each iteration
    \item gamma: Vector of selected gamma parameters for each iteration
    \item num_iterations: Number of iterations performed
    \item feature_scaling: Scaling information for predictors (if standardize=TRUE)
    \item lambda_selection_rule: The rule used for lambda selection.
  }
}
\description{
Implements the Structure-Adaptive Elastic Net (SAEnet) method, which extends
the elastic net framework by incorporating external structural information.
This approach translates external information about predictors into different
penalization strengths for the regression coefficients.
}
\details{
The Structure-Adaptive Elastic Net incorporates external structural information
to improve variable selection in high-dimensional regression. The method adapts
the standard elastic net by allowing the adaptive weights to depend on external
structural information, which can be either group-based or covariate-dependent.

The algorithm follows an iterative procedure:
1. Initialize by fitting a standard elastic net
2. Generate adaptive weights based on the structural information
3. Solve the weighted elastic net problem
4. Repeat steps 2-3 for a specified number of iterations
}
\examples{
# Generate common example data
set.seed(123)
n <- 100  # number of observations
p <- 50   # number of variables
X_data <- matrix(rnorm(n * p), n, p)
colnames(X_data) <- paste0("V", 1:p)
# True beta: first 5 are strong, next 5 are moderate, rest are zero
true_beta <- c(rep(1.5, 5), rep(0.3, 5), rep(0, p - 10))
y_data <- X_data \%*\% true_beta + rnorm(n, 0, 0.75) # Slightly more noise

# --- Demonstrating the benefit of structure (using BIC for selection) ---
message("--- Comparing Models (BIC selection, max_iter=3, num_folds=3 for CV parts if any) ---")

# 1. Standard SAEnet (No Structure)
fit_no_structure_bic <- saenet(y = y_data, x = X_data, max_iterations = 3,
                               lambda_selection_rule = "bic",
                               num_cores = 1, verbose = FALSE, num_folds = 3)
nz_no_structure <- sum(abs(predict(fit_no_structure_bic, type = "coefficients")) > 1e-8)
crit_no_structure <- tail(fit_no_structure_bic$criterion_value, 1)
message(sprintf("No Structure (BIC): Non-zero coefs = \%d, Final BIC = \%.2f",
                nz_no_structure, crit_no_structure))

# 2. Group-based Structure
# Define groups: first 10 variables (true signals) in one group, rest in another
groups_meaningful <- c(rep(1, 10), rep(2, p - 10))
structure_group_meaningful <- list(group = groups_meaningful)
fit_group_bic <- saenet(y = y_data, x = X_data,
                        structure_info = structure_group_meaningful,
                        max_iterations = 3, lambda_selection_rule = "bic",
                        num_cores = 1, verbose = FALSE, num_folds = 3)
nz_group <- sum(abs(predict(fit_group_bic, type = "coefficients")) > 1e-8)
crit_group <- tail(fit_group_bic$criterion_value, 1)
message(sprintf("Group Structure (BIC): Non-zero coefs = \%d, Final BIC = \%.2f",
                nz_group, crit_group))

# 3. Covariate-dependent Structure
# Define a covariate: higher values for the first 10 true signal variables
covariate_meaningful <- rep(0.1, p)
covariate_meaningful[1:10] <- 1.0 # Higher value for true signals
covariate_meaningful[6:10] <- 0.7 # Moderately high for moderate signals
structure_cov_meaningful <- list(covariate = matrix(covariate_meaningful, ncol = 1))
fit_covariate_bic <- saenet(y = y_data, x = X_data,
                            structure_info = structure_cov_meaningful,
                            max_iterations = 3, lambda_selection_rule = "bic",
                            num_cores = 1, verbose = FALSE, num_folds = 3)
nz_covariate <- sum(abs(predict(fit_covariate_bic, type = "coefficients")) > 1e-8)
crit_covariate <- tail(fit_covariate_bic$criterion_value, 1)
message(sprintf("Covariate Structure (BIC): Non-zero coefs = \%d, Final BIC = \%.2f",
                nz_covariate, crit_covariate))

}
\references{
Pramanik, S., & Zhang, X. (2020). Structure Adaptive Elastic-Net. arXiv:2006.02041.
}
